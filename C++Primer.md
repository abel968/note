## 第７章
- c++函数返回类型不能是数组，但可以将数组作为结构或对象组成部分返回
- **二维数组作为函数的参数**
  ```c++
  int data[3][4];
  int sum(int (*ar2)[4], int size);//[]优先级比*高，括号不能少，因为是4个指向int的指针组成的数组，而不是指向由4个int组成的数组的指针
  int sum(int ar2[][4], int size); //另一种格式，可读性更强。
  ```
- 函数名就是函数的地址。声明指向特定类型的函数的指针，先编写该函数的原型，然后用(*function)代替函数名即可。也可以*使用c++11的自动推断功能**
  ```c++
  double pam(int);   // 函数声明
  double (*pf)(int);  // 函数指针声明
  pf = pam;  //此时pf指向pam
  (*pf)(4);  //使用指针调用函数，应使用(*pf), c++也允许像函数名一样使用函数指针，如pf(4)。但用(*pf)可以显示正在使用函数指针。
  auto pf2 = pam; //可以使用c++11的自动推断类型功能。
  ```
- 声明函数指针数组。此时不能用auto，auto只能用于单值初始化，而不能用于初始化列表
  ```c++
  const double * (*pa[3]) (int) = {f1, f2, f3} //包含初始化
  auto pb = pa;  //此时可以用auto
  ```
- typedef 应用于函数指针类型的别名，如：`typedef double (*pf_name)(int)` 。此时pf_name是该函数指针类型的别名
## 第8章
- 内联函数与普通函数不同的地方在于：普通函数被调用时是跳到另一个函数地址，而内联函数是由编译器将使用的函数代码替代函数调用，即不需要跳。因此内联函数运行更快，但占更多内存，一般用于代码量少调用多的函数。内联函数不能递归，但和普通函数一样是值传递（这是与宏定义主要区别）。
- 函数参数是基本数据类型时应使用按值传递，数据比较大用引用。引用只有在const类型才能传递表达式的值,此时编译器创建临时变量。
- 一种似乎不错的函数定义方式  `A& func(A& a);` 即将void改为A的引用，在调用上更随意。**将const用于返回引用可能有挺好的限制**
- 函数重载时，若参数不与任何原型匹配，则c++尝试使用类型转换再匹配，若只匹配到一个则调用，若多个则出错。const类型可用于重载
- 模板并不创建任何函数，只是告诉编译器如何定义函数，当需要某个类型的函数时，编译器按照模板格式创建这样的函数。
- 显式具体化
  ```c++
  template <typename T>
  void Swap(T&, T&);

  template <> void Swap<job>(job&, job&); //显式具体化  或者 template <> void Swap(job&, job&);
  template <> void Swap<job>(job&, job&)   //显式具体化定义
  {

  }
  ```
- 编译器选择函数原型时，先找非模板版本，然后找显示具体化，最后找普通模板。
- 实例化，分为隐式实例化和显示实例化。隐式的为调用的时候编译器生成，显式的为`template void Swap<int> (int, int);`
- 若有一个`Add(T, T)`模板。a为double，b为int。此时用`Add(a,b)`会不匹配，但可用`Add<double>(a,b)`
- **decltype** c++11新增关键字 `decltype(x) y`可以使y具有x的类型。若x是函数调用，并不会调用函数，而是查看函数返回类型。`decltype ((x)) y = x` 此时y为x类型的引用
- c++提供另一种函数声明方式。`auto h(int x, float y) -> double` auto是一个占位符，表示后置返回类型。这次为了用于模板。`auto h(T1 x, T2 y) -> decltype(x+y)`
- 在类中定义的函数为内联函数
##　第九章
- 静态存储持续性变量的３种链接性：　外部链接性，内部链接性，无链接性。**静态变量在程序执行期间一直存在。**无链接性的静态变量用于在两次函数调用之间，静态局部变量的值保持不变。即若初始化了一次，则程序只在启动时进行一次初始化。
  ```c++
  int global = 1;　　　　　　　　　//外部链接性，可在其他文件访问
  static int one_file = 2;　　　　//内部链接性，只能在当前文件访问
  void func()
  {
      static int count = 0;    //无链接性，只能在当前代码块访问
  }
  ```
- volatile　由于编译器会优化代码，比如在几条语句访问一个变量两次时，编译器不会让程序查这个变量两次，而volatile会阻止这样的优化
- mutable  可以用于在结构体中的成员变量，即使结构体被声明const，但其被mutable修饰的成员也能改变
- const全局变量，会将其链接性改为内部。即`const int a = 5; static const int a = 5;` 它们的效果是一样的。这样可以将一组常量放在头文件中，同一个程序的多个文件使用该头文件也不会出错。再加extern可以将其链接性改为外部。
- 可以使用static将函数的链接性设置为内部的。可以用extern指出某个函数是在外部定义的。
- 语言链接性。c语言和c++会将function函数翻译为不同的名字，为了在c++程序中使用c库，可以使用extern
  ```c++
  extern "C" void spiff(int);  // 使用c语言的约定来搜索
  extern void spiff(int);  // 使用c++的约定来搜索
  extern "C++" void spiff(int);  // 使用c++的约定来搜索, 和上一个是一致的。
  ```
- new失败时引发异常std::bad_alloc
- 定位new运算符。。可以指定申请的位置。   P456 也有new定位 关于对象的
- 名称空间可以是全局的，也可以在另一个名称空间中。**但不能位于代码块中**。默认情况下，名称空间的声明的链接性是外部的，除非用了const
- `using Jill::fetch` 可以直接使用fetch
- 若名称空间和声明区域定义了相同的名称，若用using声明会出错，而用using 编译指令，局部会隐藏名称空间变量
- 可以自己定义一个名称空间myth，在该空间中使用using编译指令和using声明。然后直接using namespace myth;可以导入其空间内的所有名称
- 名称空间可以有别名。如:`namespace my = myth::std::fdsf;`
- 可以省略名称来创建为命名的名称空间。与链接性为内部的静态变量是等价的。
  ```c++
  namespace
  {
      int a;
      int b;
  }
  ```
- using声明只使用了名称，所以若函数被重载，则一个using声明导入所有同名函数
- 若局部变量隐藏了全局变量，可以使用`::a`方式来访问全局变量
## 第10章
- 隐式调用默认构造函数时，不要使用圆括号。如：`Stock s();`是函数声明，而不是构造函数
- 与结构体赋值一样，默认情况下，类对象赋值将会把一个对象的成员复制给另一个。
- c++11可以使用列表初始化用于类。只需要某个构造函数的参数与列表匹配。如`Stock s {1,2};`可以和Stock(int, int)匹配
- **只要类方法不修改对象，就将其声明为const**
- 创建有显式定义构造函数的类的数组
  ```c++
  Stock stocks[] = {
      Stock("1"),
      Stock("2"),
      Stock("3", 130),
      Stock(),
  }
  ```
- 在类中创建所有对象共享的常量，有两种方法（枚举和static）：
  ```c++
  class A
  {
      enum {Months1 = 12};            // 使用枚举方法
      static const int Months2 = 12;  // static方法
  }
  ```
- 传统的枚举可能会出现冲突，如：
  ```c++
  enum egg {Small, Large};   //直接 Small访问
  enum egg2 {Small, Large};  // 两个Small在同一个作用域内，此时会出现冲突
  // 可以使用类作用域
  enum class egg {Small, Large};
  enum class egg2 {Small, Large};  // 分别用egg::Small egg2::Small 来访问
  ```
- 常规枚举自动转换为整型，类的作用域枚举不能隐式的转换为整型
## 第11章
- 重载运算符。`operatorop(argument-list)`
- `A1+A2`调用的是`A1.operator+(A2)`
- 不能重载的运算符 `sizeof .  .*  ::  ?:  typeid   四个转换`
- 大多数云算法可以通过非成员函数重载，但以下几个只能通过成员函数重载。 `= () [] ->`
- 非成员函数重载的必要性：T是自己定义的类。T*double类型可以用成员函数，但double类型*T只能用非成员函数operator*(double,T)
- 创建友元函数(其访问权限与成员函数相同)：
  1. 在类中声明函数原型，在正常的函数原型前加上friend即可
  2. 编写函数定义，不要用::限定符
- 友元函数可以用于重载<<:
  ```c++
  ostream & operator<<(ostream & os, const Time& t)   // 该函数是类Time的友元
  {
      os << t.hours << "hours, " << t.minutes << " minutes";
      return os;
  }
  ```
- c++只接受一个参数的构造函数为该参数相同类型的值提供隐式转换。 如`Stone(int);` 则`Stone s=5;`相当于调用`Stone s(5);` 
- 如果给构造函数添加explicit关键字，可以关闭上述的隐式转换。即`explicit Stone(int)`。但显式转换还是可行
- 若只有原型`Stone(double);`,`Stone J = 7300;` 7300会被先转为double类型再构造。但若还有`Stone(long)`声明，则会报错，因为有二义性
- 转换函数。`operator typeName();` 
  1. 转换函数必须是类方法
  2. 转换函数不能指定返回类型
  3. 转换函数不能有参数。
  如：
　```c++
  Stone::operator int() const
  {
      return num;
  }
  ```
- c++11可以允许关键字explicit用于转换函数。则转换必须是显式的。用于构造函数也一样.
- 将加法定义为友元可以让程序更容易适应自动类型转换
## 第12章
- 类的静态成员变量。在类中只能做声明，在cpp文件中初始化，如`int A::num = 0;`。注意不能在头文件初始化，否则会链接错误。
- 若静态成员是const整型或枚举型，可以在类声明中初始化。
- **五种特殊的成员函数，当未定义时会自动生成**
  1. 默认构造函数，当未定义构造函数时
  2. 默认析构函数
  3. 复制构造函数
  4. 赋值运算符
  5. 地址运算符
- 新建一个对象并将其初始化为同类现有对象/函数按值传递和返回对象时，复制构造函数将被调用。以下四种(**中间两种可能会用复制构造函数直接创建，也可能先生成临时对象，然后赋值**)：
  ```c++
  StringBad ditto(motto);
  StringBad metto = motto;
  StringBad also = StringBad(motto);
  StringBad * pStringBad = new StringBad(motto);
  ```
- **若类中包含了用new初始化的指针成员，应当定义一个复制构造函数和一个赋值运算符，深拷贝**
- 类中将已有对象赋给另一个对象，将使用重载的赋值运算符。但初始化对象时，如`StringBad metto = knot;`可能使用可能不用赋值运算符。
- 类中包含用new初始化的指针成员的 赋值运算符声明应为： 
  ```c++
  StringBad & StringBad::operateor=(const StringBad & st)
  {
      if (this == &st)
          return *this;    //检查是否自己等于自己
      delete [] str;       //释放自己之前的指针所指内存
      // 下面深拷贝
      return *this;
  }
  ```
- c++98用0表示空指针，但在c++11支持用nullptr表示空指针，但0依然可以使用
- c++在重载时，区分常量和非常量函数的特征标。这是为了解决
  ```c++
  String s1("sdf");
  s1[0] = 6; //此时调用的是char & String::operator[](int i)  该数据位可以被改变
  const String s2("dsf");
  cout<<s2[0]<<endl;  //此时，因为s2为const型，无法调用上一个函数，应使用const char & String::operator[](int i) const;
  ```
- 静态成员函数。不能通过对象调用，不能用this指针，只能访问静态数据成员。
- 类的构造和析构函数，注意new和delete的兼容。即若有多个构造函数，要么都带中括号，要么都不带。
- delete无论带不带[]都可以用于空指针
- 初始化列表 必须用这种格式初始化非静态成员，初始化引用数据成员。数据成员初始化的顺序与其在类声明的顺序相同。
- c++11允许在类内初始化，这和使用初始化列表等价。
- 将复制构造函数和赋值构造函数声明为私有的。这可以避免编译器自动生成，造成不好的影响。如：
  ```c++
  class Q
  {
      private:
      Q(const Q& q) {}
      Q& operat一样or=(const Q& q) {return *this;}
  }
  ```
## 第十三章
- 派生类构造函数需要利用初始化列表调用基类的构造函数, 若在初始化列表中省略基类的构造函数，将使用无参数的默认构造函数
- 基类 指针/引用 可以在不进行显示转换的情况下指向/引用派生类对象，但只能调用基类方法，不能调用派生类方法。
- 基类声明为vritual的方法，在派生类中自动成为虚方法。但建议派生类中也写明virtual
- 基类要声明虚析构函数，为了保证释放派生对象时正确释放。
- 在派生类函数需要调用基类函数时，需要使用作用域解析运算符。如`Basic::func()`
- 静态联编和动态联编。virtual是动态联编。静态联编的效率更高，因此若基类方法不需要重新定义应不使用virtual
- 编译器处理虚函数的方法：给每个对象添加一个隐藏成员保存指向一个函数地址数组的指针，叫虚函数表。基类指向一个虚函数表，派生类也指向另一个独立的虚函数表。
- 友元不能是虚函数，因为友元不是类成员
- 若在派生类中重新定义某个函数并不是重载，而是隐藏基类的同名函数，不管是否相同的特征标。如在基类中有`show(int)`函数，在派生类中`show()`函数，则基类中的该函数将被隐藏。**因此，若重新定义继承的方法，应确保和原来的原型完全相同，但若返回类型是基类引用或指针，可以改为派生类的引用或指针(这叫返回类型协变)。若基类声明被重载了，应在派生类中重新定义所有基类该声明函数。若不需要修改的话，可以在派生类中只调用基类版本。如`void Child::func() {Father::func();}`**
- c++使用纯虚函数提供未实现的函数。纯虚函数只需要在声明的结尾处=0。但纯虚函数允许有定义。
- 当派生类使用了new时,应向之前一样注意析构函数,复制构造函数和赋值运算符.
  ```c++
  // 析构函数只需要delete派生类的new即可, 基类的new会调用基类的析构函数释放
  // 复制构造函数, 使用初始化列表构造基类
  Father::Father(const Father & f) : Base(f)
  {
    // do something
  }
  // 赋值运算符.
  Father& Father::operator=(const Father & f)
  {
    if (this == &f) return *this;
    Base::operator=(f);   
    // delete 赋值操作.
  }
  ```
- 使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换.
- 构造函数, 析构函数, 赋值运算符是不能被继承的.
## 第14章
- valarray用于处理数值,支持将数组中所有元素相加以及找到最大最小值等操作.`valarray<int> v1(8);`数组大小为8. `valarray<int> v1(10, 8);`数组大小为8, 全部初始化为10. 也可以使用初始化列表:`valarray<int> v3 = {1,2,3};`  其一些方法为: size() sum() max() min()
- 对于只有一个参数的构造函数应尽量使用explicit
- 构造函数初始化时,当一个成员的值作为另一个成员的初始化表达式的一部分时,初始化顺序非常重要
- 使用私有继承,基类的公有成员和保护成员变成私有成员. 但派生类中可以使用这些成员. 私有继承和包含类似,都是has-a关系s
- 使用多个基类的继承为多重继承, 即MI
- 包含使用对象名来调用方法,而私有继承使用类名和作用域解析运算符来调用方法, 使用强制类型转换和*this来访问基类对象 以及友元函数operator<<
- 通常使用包含来建立has-a关系, 若心类需要访问原有类的保护成员或重新定义虚函数, 则应使用私有继承
- using声明可以使派生类使用特性的基类成员函数
- 虚基类使多个基类相同的类,派生出的对象只继承一个基类对象.在类声明继承的public位置加入virtual. public和virtual顺序不重要
- 虚基类................??P558
- `template <class T, int>` 指出T为类型参数, n的类型为int. 表达式参数(即此处的int)可以是整型, 枚举, 引用或指针, 且模板代码不能修改该参数的值,也不能使用参数的地址. 实例化模板时,用作表达式参数的值必须是常量表达式
- 模板函数可以作为基类
- 默认类型模板参数 如`template <class T1, class T2=int>`
- 隐式实例化(创建类对象时), 显式实例化(`template class ArrayTP<string, 10>`), 显式具体化(`template <> class ArrayTP<string, 10>`是对特定类型的定义,替换模板中的泛型)
- 部分具体化 如对于`template <class T1, class T2> class Pair` 可以部分具体化,重新定义`template <class T1> class Pair<T1, int>`. 也可以通过指针进行部分具体化, 如对于`template <class T> Feeb` 可以使用`template <class T*> Feeb`重新定义
- 成员模板, 将模板用作参数, 模板类和友元 P586
- 模板别名, c++11允许将using=用于非模板和模板  `using pc = const char *`相当于typedef; 也可以`template<typename T> using arrtype = std::array<T,12>` 然后就可以使用`arrtype<int> days`
## 第15章















